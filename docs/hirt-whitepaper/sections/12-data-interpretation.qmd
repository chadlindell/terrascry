---
title: "Data Interpretation"
---

## Overview {#sec-interpretation-overview}

This section provides comprehensive guidance on interpreting HIRT field data, including depth of investigation, lateral resolution, and what each measurement method detects. Effective interpretation requires understanding both the physics of the measurements and the geological/archaeological context of the survey site.

## Data Processing Pipeline {#sec-processing-pipeline}

HIRT data processing follows a systematic pipeline from raw field acquisition through final interpretation. Each stage validates and refines the data to produce reliable subsurface images.

```{python}
#| label: fig-processing-pipeline
#| fig-cap: "HIRT data processing pipeline from raw field measurements through tomographic inversion to final 3D visualization. Processing times shown are typical for a 4x4 probe grid survey."

import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
from matplotlib.patches import FancyBboxPatch, Polygon
import numpy as np

COLORS = {
    'primary': '#1a365d',
    'secondary': '#2c5282',
    'accent': '#3182ce',
    'success': '#38a169',
    'warning': '#c53030',
    'orange': '#ed8936',
    'purple': '#805ad5',
    'gray_dark': '#4a5568',
    'light_blue': '#ebf8ff',
    'light_green': '#c6f6d5',
    'light_orange': '#feebc8',
    'light_purple': '#e9d8fd',
}

fig, ax = plt.subplots(figsize=(11, 6.5))
ax.set_xlim(0, 11)
ax.set_ylim(0, 6.5)
ax.set_aspect('equal')
ax.axis('off')

ax.text(5.5, 6.2, 'HIRT Data Processing Pipeline', ha='center',
        fontsize=12, fontweight='bold', color=COLORS['primary'])

def draw_process_box(ax, x, y, w, h, text, color):
    ax.add_patch(FancyBboxPatch((x - w/2, y - h/2), w, h,
                 boxstyle="round,pad=0.03", facecolor=color,
                 edgecolor='black', linewidth=1))
    lines = text.split('\n')
    for i, line in enumerate(lines):
        ax.text(x, y + (len(lines)/2 - i - 0.5) * 0.2, line,
               ha='center', va='center', fontsize=8, fontweight='bold')

def draw_flow_arrow(ax, start, end):
    ax.annotate('', xy=end, xytext=start,
               arrowprops=dict(arrowstyle='->', color='black', lw=1.5))

def draw_terminal(ax, x, y, w, h, text, color):
    ax.add_patch(FancyBboxPatch((x - w/2, y - h/2), w, h,
                 boxstyle="round,pad=0.3", facecolor=color,
                 edgecolor='black', linewidth=1.5))
    ax.text(x, y, text, ha='center', va='center', fontsize=9, fontweight='bold')

# Main stages (top row)
main_stages = [
    (1.2, 4.5, 'Raw Field\nData', COLORS['light_blue'], 'ADC samples\nfrom probes'),
    (3.5, 4.5, 'Filter &\nAverage', COLORS['light_green'], 'Noise\nreduction'),
    (5.8, 4.5, 'Background\nRemoval', COLORS['light_green'], 'Anomaly\nextraction'),
    (8.1, 4.5, 'Reciprocity\nCheck', COLORS['light_orange'], 'QA/QC\nvalidation'),
]

# Inversion stages (bottom row)
inversion_stages = [
    (1.2, 2.0, 'Tomographic\nInversion', COLORS['light_purple'], 'SIRT/ART\nalgorithms'),
    (3.5, 2.0, 'MIT/ERT\nFusion', COLORS['light_green'], 'Multi-modal\nintegration'),
    (5.8, 2.0, '3D Model\nGeneration', COLORS['light_blue'], 'Voxel grid\nbuilding'),
    (8.1, 2.0, 'Visualization\n& Report', COLORS['light_orange'], 'Depth slices\nisosurfaces'),
]

for x, y, text, color, detail in main_stages:
    draw_process_box(ax, x, y, 1.8, 1.0, text, color)
    ax.text(x, y - 0.75, detail, ha='center', va='top', fontsize=6,
            color=COLORS['gray_dark'], style='italic')

for x, y, text, color, detail in inversion_stages:
    draw_process_box(ax, x, y, 1.8, 1.0, text, color)
    ax.text(x, y - 0.75, detail, ha='center', va='top', fontsize=6,
            color=COLORS['gray_dark'], style='italic')

# Horizontal arrows (top row)
for i in range(len(main_stages) - 1):
    draw_flow_arrow(ax, (main_stages[i][0] + 0.9, 4.5),
                    (main_stages[i+1][0] - 0.9, 4.5))

# Vertical transition
draw_flow_arrow(ax, (8.1, 4.0), (8.1, 3.3))
ax.annotate('', xy=(1.2, 2.5), xytext=(8.1, 3.0),
            arrowprops=dict(arrowstyle='->', color='black', lw=1.5,
                           connectionstyle='angle,angleA=0,angleB=90'))

# Horizontal arrows (bottom row)
for i in range(len(inversion_stages) - 1):
    draw_flow_arrow(ax, (inversion_stages[i][0] + 0.9, 2.0),
                    (inversion_stages[i+1][0] - 0.9, 2.0))

# Terminal nodes
draw_terminal(ax, 0.3, 4.5, 0.6, 0.5, 'IN', COLORS['light_blue'])
draw_flow_arrow(ax, (0.6, 4.5), (0.3, 4.5))
draw_flow_arrow(ax, (8.1 + 0.9, 2.0), (10.0, 2.0))
draw_terminal(ax, 10.3, 2.0, 0.8, 0.5, 'END', COLORS['light_green'])

# Time estimates
ax.text(2.35, 5.3, '~1-5s', fontsize=7, ha='center', color=COLORS['accent'])
ax.text(4.65, 5.3, '~2-5s', fontsize=7, ha='center', color=COLORS['accent'])
ax.text(6.95, 5.3, '~1-2s', fontsize=7, ha='center', color=COLORS['accent'])
ax.text(2.35, 1.0, '~30-60s', fontsize=7, ha='center', color=COLORS['accent'])
ax.text(4.65, 1.0, '~5-10s', fontsize=7, ha='center', color=COLORS['accent'])
ax.text(6.95, 1.0, '~10-20s', fontsize=7, ha='center', color=COLORS['accent'])

# Phase labels
ax.text(0.2, 5.5, 'DATA\nACQUISITION', fontsize=7, va='center',
        fontweight='bold', color=COLORS['accent'], rotation=90)
ax.text(0.2, 2.5, 'INVERSION\n& OUTPUT', fontsize=7, va='center',
        fontweight='bold', color=COLORS['purple'], rotation=90)

plt.tight_layout()
plt.show()
```

## Processing Stages

1. **Data Acquisition:** Raw ADC samples collected from probe pairs
2. **Filter and Average:** Noise reduction through digital filtering and stacking
3. **Background Removal:** Subtract homogeneous response to isolate anomalies
4. **Reciprocity Check:** Validate A-to-B equals B-to-A for quality assurance
5. **Tomographic Inversion:** Reconstruct 3D conductivity/resistivity distribution
6. **MIT/ERT Fusion:** Combine multi-modal data for comprehensive interpretation
7. **3D Model Generation:** Build voxel grid from inverted data
8. **Visualization:** Generate depth slices, isosurfaces, and reports

## Depth of Investigation {#sec-depth-investigation}

The achievable investigation depth depends on several factors including probe depth, probe spacing, soil conductivity, and measurement frequency. Understanding these relationships is essential for survey planning and result interpretation.

## Factors Affecting Depth

- **Probe depth:** Deeper insertion enables deeper sensitivity
- **Probe spacing:** Wider spacing increases depth but reduces lateral resolution
- **Soil conductivity:** Lower conductivity enables deeper signal penetration
- **Frequency (MIT):** Lower frequency provides deeper sensitivity
- **Current geometry (ERT):** Longer baselines enable deeper investigation

| Configuration | MIT Depth | ERT Depth | Combined | Confidence |
|---------------|-----------|-----------|----------|------------|
| 1.5m probes, 1.5m spacing | 1.5-2.5m | 2-3m | 2-3m | HIGH |
| 1.5m probes, 2.0m spacing | 2-3m | 2-3m | 2-3m | HIGH |
| 3.0m probes, 2.0m spacing | 3-4m | 3-5m | 3-5m | MEDIUM |
| 3.0m probes, 2.5m spacing | 3-4m | 4-6m | 4-6m | LOW |

: Depth of investigation by configuration {#tbl-depth-investigation}

::: {.callout-note}
The commonly cited '3-6m' depth range represents favorable conditions only. For most field conditions, expect 2-4m typical depth, with up to 5-6m achievable in optimal soil conditions with longer probes and wider spacing.
:::

## Lateral Resolution {#sec-lateral-resolution}

Lateral resolution approximately equals 0.5 to 1.5 times the probe spacing. Tighter spacing provides finer resolution but requires more survey time, while wider spacing offers faster coverage with coarser resolution.

| Spacing | Lateral Resolution | Best Application |
|---------|-------------------|------------------|
| 1.0 m | 0.5-1.5 m | High-resolution burial/artifact search |
| 1.5 m | 0.75-2.25 m | Standard WWII crash investigation |
| 2.0 m | 1.0-3.0 m | Large feature reconnaissance |

: Resolution by probe spacing {#tbl-resolution}

## HIRT vs Surface Methods {#sec-hirt-vs-surface}

HIRT's crosshole geometry provides 2-5 times better resolution than surface methods at depths greater than 2m. This advantage increases with depth due to direct ray paths and elimination of surface clutter.

| Method | Lateral Res. | Depth Res. | At 3m Depth |
|--------|--------------|------------|-------------|
| Surface Magnetometry | 1-2m | Poor | ~2m lateral |
| GPR (in sand) | 0.3-0.5m | 0.05-0.1m | Degrades to 1m+ |
| GPR (in clay) | Limited | Limited | Often fails |
| Surface ERT (Wenner) | ~1x spacing | ~0.5x spacing | ~2-3m |
| HIRT (1.5m spacing) | 0.75-1.5m | 0.5-0.75m | ~1m lateral |
| HIRT (2m spacing) | 1-2m | 0.5-1m | ~1.5m lateral |

: Resolution comparison: HIRT vs surface methods {#tbl-method-comparison}

::: {.callout-note}
## Why HIRT Achieves Better Resolution

- Direct ray paths through target volume (not down-and-back)
- No surface clutter from topography and cultural noise
- True 3D sampling enables genuine tomographic reconstruction
- Better depth discrimination between targets at different depths
:::

## Anomaly Classification {#sec-anomaly-classification}

MIT and ERT respond differently to various subsurface features. Understanding these response characteristics enables accurate classification of detected anomalies.

```{python}
#| label: fig-anomaly-classification
#| fig-cap: "Anomaly classification chart showing expected MIT and ERT response levels for common target types encountered in archaeological and forensic investigations."

import matplotlib.pyplot as plt
from matplotlib.patches import FancyBboxPatch, Rectangle, Circle
import numpy as np

COLORS = {
    'primary': '#1a365d',
    'success': '#38a169',
    'warning': '#c53030',
    'orange': '#ed8936',
    'purple': '#805ad5',
    'accent': '#3182ce',
    'gray_dark': '#4a5568',
    'gray_light': '#a0aec0',
    'light_blue': '#ebf8ff',
}

fig, ax = plt.subplots(figsize=(10, 7))
ax.set_xlim(0, 10)
ax.set_ylim(0, 7)
ax.axis('off')

ax.text(5, 6.7, 'Anomaly Classification: MIT vs ERT Response', ha='center',
        fontsize=12, fontweight='bold', color=COLORS['primary'])

categories = [
    ('Metal Objects', 'Strong', 'Weak/None', COLORS['warning'],
     ['Engine parts', 'Aircraft wreckage', 'Artifacts']),
    ('Conductive Soil', 'Moderate', 'Moderate', COLORS['orange'],
     ['Wet clay', 'Saline zones', 'Contamination']),
    ('Disturbed Fill', 'Weak', 'Strong', COLORS['purple'],
     ['Crater fill', 'Grave shafts', 'Backfill']),
    ('Voids/Air', 'None', 'Strong', COLORS['gray_light'],
     ['Cavities', 'Collapsed zones', 'Air pockets']),
    ('Moisture Zones', 'Weak', 'Strong', COLORS['accent'],
     ['Water table', 'Wet pockets', 'Seepage']),
]

headers = ['Target Type', 'MIT Response', 'ERT Response', 'Examples']
x_positions = [1.2, 3.5, 5.5, 8.0]

for i, (header, x) in enumerate(zip(headers, x_positions)):
    ax.add_patch(FancyBboxPatch((x - 0.9, 5.8), 1.8 if i < 3 else 3.2, 0.5,
                                 boxstyle="round,pad=0.02",
                                 facecolor=COLORS['primary'],
                                 edgecolor='black', lw=1))
    ax.text(x, 6.05, header, ha='center', va='center',
            fontsize=9, fontweight='bold', color='white')

for row_idx, (target_type, mit, ert, color, examples) in enumerate(categories):
    y = 5.2 - row_idx * 1.0

    ax.add_patch(FancyBboxPatch((0.3, y - 0.35), 1.8, 0.7,
                                 boxstyle="round,pad=0.02",
                                 facecolor=color, alpha=0.3,
                                 edgecolor=color, lw=1.5))
    ax.text(1.2, y, target_type, ha='center', va='center', fontsize=8,
            fontweight='bold', color=COLORS['gray_dark'])

    ax.add_patch(FancyBboxPatch((2.6, y - 0.35), 1.8, 0.7,
                                 boxstyle="round,pad=0.02",
                                 facecolor='white', edgecolor=COLORS['gray_light'], lw=0.5))
    ax.text(3.5, y, mit, ha='center', va='center', fontsize=8)

    mit_level = {'Strong': 0.9, 'Moderate': 0.5, 'Weak': 0.25, 'None': 0.0}[mit]
    ax.add_patch(Rectangle((2.7, y - 0.25), 1.6 * mit_level, 0.15,
                           facecolor=COLORS['success'], alpha=0.7))

    ax.add_patch(FancyBboxPatch((4.6, y - 0.35), 1.8, 0.7,
                                 boxstyle="round,pad=0.02",
                                 facecolor='white', edgecolor=COLORS['gray_light'], lw=0.5))
    ax.text(5.5, y, ert, ha='center', va='center', fontsize=8)

    ert_level = {'Strong': 0.9, 'Moderate': 0.5, 'Weak': 0.25, 'None': 0.0, 'Weak/None': 0.1}[ert]
    ax.add_patch(Rectangle((4.7, y - 0.25), 1.6 * ert_level, 0.15,
                           facecolor=COLORS['orange'], alpha=0.7))

    ax.add_patch(FancyBboxPatch((6.4, y - 0.35), 3.2, 0.7,
                                 boxstyle="round,pad=0.02",
                                 facecolor='white', edgecolor=COLORS['gray_light'], lw=0.5))
    examples_text = ', '.join(examples)
    ax.text(8.0, y, examples_text, ha='center', va='center', fontsize=7,
            style='italic', color=COLORS['gray_dark'])

ax.add_patch(Rectangle((0.5, 0.3), 0.4, 0.15, facecolor=COLORS['success'], alpha=0.7))
ax.text(1.0, 0.375, 'MIT Response Level', fontsize=7, va='center')
ax.add_patch(Rectangle((3.5, 0.3), 0.4, 0.15, facecolor=COLORS['orange'], alpha=0.7))
ax.text(4.0, 0.375, 'ERT Response Level', fontsize=7, va='center')

ax.add_patch(FancyBboxPatch((6.0, 0.1), 3.8, 0.6,
                             boxstyle="round,pad=0.05",
                             facecolor=COLORS['light_blue'],
                             edgecolor=COLORS['accent'], lw=1.5))
ax.text(7.9, 0.4, 'KEY: Combine MIT + ERT for complete picture',
        ha='center', va='center', fontsize=8, fontweight='bold',
        color=COLORS['primary'])

plt.tight_layout()
plt.show()
```

## MIT (Magneto-Inductive Tomography) Detection

- **Metal objects:** Strong response to aluminum, steel, and iron
- **Conductive regions:** Moderate response to saline water, clay layers
- **Eddy current anomalies:** Metallic wreckage produces characteristic signatures
- Phase lag indicates conductivity; amplitude indicates size/distance
- Higher frequencies provide better near-surface sensitivity

## ERT (Electrical Resistivity) Detection

- **Disturbed fill:** Different compaction and moisture than native soil
- **Moisture variations:** Wet zones appear as low resistivity
- **Crater walls:** Clear boundaries between fill and native soil
- **Voids:** Air-filled spaces show very high resistivity
- Depth slices reveal layering and lateral extent of features

## Example Tomogram Interpretation {#sec-example-tomogram}

The following example demonstrates combined MIT and ERT interpretation for a simulated WWII crash site investigation. Note how the complementary data streams provide more complete subsurface characterization than either method alone.

```{python}
#| label: fig-tomogram-example
#| fig-cap: "Example tomogram showing MIT conductivity (top left), ERT resistivity (top right), and combined interpretation (bottom). The metal target within the disturbed fill zone is identified as a high-priority excavation target."

import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
import numpy as np

COLORS = {
    'primary': '#1a365d',
}

fig = plt.figure(figsize=(11, 6), constrained_layout=True)
gs = fig.add_gridspec(2, 3, width_ratios=[1, 1, 0.05], hspace=0.15, wspace=0.2)

# MIT tomogram
ax_mit = fig.add_subplot(gs[0, 0])
x = np.linspace(0, 5, 100)
z = np.linspace(0, 4, 80)
X, Z = np.meshgrid(x, z)

target_x, target_z = 2.5, 2.5
distance = np.sqrt((X - target_x)**2 + (Z - target_z)**2)
mit_data = np.exp(-distance**2 / 0.3) * 100
mit_data += np.random.randn(*mit_data.shape) * 2
mit_data = np.clip(mit_data, 0, 100)

im_mit = ax_mit.imshow(mit_data, extent=[0, 5, 4, 0], cmap='hot',
                       aspect='auto', vmin=0, vmax=100)
ax_mit.set_xlabel('Distance (m)', fontsize=9)
ax_mit.set_ylabel('Depth (m)', fontsize=9)
ax_mit.set_title('MIT Conductivity (mS/m)', fontsize=10, fontweight='bold',
                 color=COLORS['primary'])
ax_mit.plot(target_x, target_z, 'w+', markersize=12, markeredgewidth=2)
ax_mit.annotate('Metal\nTarget', (target_x, target_z), (target_x + 1, target_z - 0.5),
                fontsize=8, color='white', fontweight='bold',
                arrowprops=dict(arrowstyle='->', color='white', lw=1.5))

for probe_x in [0.5, 4.5]:
    ax_mit.axvline(probe_x, color='cyan', linestyle='--', alpha=0.5, lw=1)
    ax_mit.text(probe_x, 0.2, 'Probe', fontsize=7, ha='center', color='cyan')

# ERT tomogram
ax_ert = fig.add_subplot(gs[0, 1])
ert_data = np.ones_like(X) * 50
crater_center_x = 2.5
for i, depth in enumerate(z):
    crater_width = max(0, 2.0 - 0.4 * depth)
    mask = np.abs(X[i, :] - crater_center_x) < crater_width
    if depth < 3.5:
        ert_data[i, mask] = 30 + np.random.randn(np.sum(mask)) * 3

moisture_dist = np.sqrt((X - 2.8)**2 + (Z - 3.0)**2)
ert_data -= np.exp(-moisture_dist**2 / 0.15) * 20
ert_data = np.clip(ert_data, 10, 80)

im_ert = ax_ert.imshow(ert_data, extent=[0, 5, 4, 0], cmap='viridis_r',
                       aspect='auto', vmin=10, vmax=80)
ax_ert.set_xlabel('Distance (m)', fontsize=9)
ax_ert.set_ylabel('Depth (m)', fontsize=9)
ax_ert.set_title('ERT Resistivity (ohm-m)', fontsize=10, fontweight='bold',
                 color=COLORS['primary'])

crater_outline_x = [0.5, 1.5, 2.0, 2.5, 3.0, 3.5, 4.5]
crater_outline_z = [0.5, 1.5, 2.5, 3.5, 2.5, 1.5, 0.5]
ax_ert.plot(crater_outline_x, crater_outline_z, 'w--', lw=2, alpha=0.7)
ax_ert.annotate('Fill\nBoundary', (3.5, 1.5), (4.2, 0.8),
                fontsize=8, color='white', fontweight='bold',
                arrowprops=dict(arrowstyle='->', color='white', lw=1.5))

ax_cb = fig.add_subplot(gs[0, 2])
ax_cb.axis('off')

# Combined interpretation
ax_combined = fig.add_subplot(gs[1, :2])
combined_data = np.zeros((*mit_data.shape, 3))
mit_norm = mit_data / 100
combined_data[:, :, 0] = mit_norm * 0.8
ert_norm = 1 - (ert_data - 10) / 70
combined_data[:, :, 1] = ert_norm * 0.6
combined_data[:, :, 2] = ert_norm * 0.8
combined_data = np.clip(combined_data, 0, 1)

ax_combined.imshow(combined_data, extent=[0, 5, 4, 0], aspect='auto')
ax_combined.set_xlabel('Distance (m)', fontsize=9)
ax_combined.set_ylabel('Depth (m)', fontsize=9)
ax_combined.set_title('Combined MIT + ERT Interpretation', fontsize=10,
                      fontweight='bold', color=COLORS['primary'])

ax_combined.plot(target_x, target_z, 'w+', markersize=15, markeredgewidth=3)
ax_combined.annotate('HIGH PRIORITY:\nMetal in Fill', (target_x, target_z),
                     (target_x + 1.2, target_z + 0.8),
                     fontsize=9, color='white', fontweight='bold',
                     bbox=dict(boxstyle='round', facecolor='red', alpha=0.7),
                     arrowprops=dict(arrowstyle='->', color='white', lw=2))

ax_combined.annotate('Disturbed\nFill Zone', (2.5, 1.5), (0.5, 0.8),
                     fontsize=8, color='white',
                     arrowprops=dict(arrowstyle='->', color='white', lw=1.5))

legend_elements = [
    mpatches.Patch(facecolor='red', alpha=0.7, label='MIT: High conductivity (metal)'),
    mpatches.Patch(facecolor='blue', alpha=0.7, label='ERT: Low resistivity (wet fill)'),
    mpatches.Patch(facecolor='purple', alpha=0.7, label='Combined: Target in disturbed zone'),
]
ax_combined.legend(handles=legend_elements, loc='lower right', fontsize=7,
                   framealpha=0.9)

fig.suptitle('Example Tomogram: WWII Crash Site Investigation',
             fontsize=12, fontweight='bold', color=COLORS['primary'])

plt.show()
```

## Interpretation Notes

- MIT clearly identifies the metal concentration at 2.5m depth
- ERT reveals the crater fill geometry and moisture distribution
- Combined view shows the target context within disturbed ground
- High-priority designation indicates both metal and disturbed fill present

## Combined Interpretation Strategy {#sec-combined-strategy}

Effective HIRT interpretation combines MIT and ERT results with site context and historical information. The following decision tree provides systematic guidance for prioritizing investigation targets.

```{python}
#| label: fig-decision-tree
#| fig-cap: "Data interpretation decision tree for prioritizing HIRT survey results. Begin with data quality verification, then evaluate MIT and ERT anomalies to assign investigation priority levels."

import matplotlib.pyplot as plt
from matplotlib.patches import FancyBboxPatch, Polygon, Circle
import numpy as np

COLORS = {
    'primary': '#1a365d',
    'success': '#38a169',
    'warning': '#c53030',
    'orange': '#ed8936',
    'purple': '#805ad5',
    'accent': '#3182ce',
    'gray_dark': '#4a5568',
    'gray_light': '#a0aec0',
    'light_blue': '#ebf8ff',
    'light_green': '#c6f6d5',
    'light_orange': '#feebc8',
    'light_red': '#fed7d7',
    'light_purple': '#e9d8fd',
}

def draw_process_box(ax, x, y, w, h, text, color):
    ax.add_patch(FancyBboxPatch((x - w/2, y - h/2), w, h,
                 boxstyle="round,pad=0.03", facecolor=color,
                 edgecolor='black', linewidth=1))
    lines = text.split('\n')
    for i, line in enumerate(lines):
        ax.text(x, y + (len(lines)/2 - i - 0.5) * 0.18, line,
               ha='center', va='center', fontsize=7, fontweight='bold')

def draw_decision_diamond(ax, x, y, size, text, color):
    half = size / 2
    points = [(x, y + half), (x + half, y), (x, y - half), (x - half, y)]
    patch = Polygon(points, facecolor=color, edgecolor='black', linewidth=1)
    ax.add_patch(patch)
    ax.text(x, y, text, ha='center', va='center', fontsize=6)

def draw_terminal(ax, x, y, w, h, text, color):
    ax.add_patch(FancyBboxPatch((x - w/2, y - h/2), w, h,
                 boxstyle="round,pad=0.3", facecolor=color,
                 edgecolor='black', linewidth=1.5))
    ax.text(x, y, text, ha='center', va='center', fontsize=8, fontweight='bold')

def draw_flow_arrow(ax, start, end, label=None):
    ax.annotate('', xy=end, xytext=start,
               arrowprops=dict(arrowstyle='->', color='black', lw=1.5))
    if label:
        mid_x = (start[0] + end[0]) / 2 + 0.15
        mid_y = (start[1] + end[1]) / 2
        ax.text(mid_x, mid_y, label, fontsize=6, color='black')

fig, ax = plt.subplots(figsize=(12, 10))
ax.set_xlim(0, 12)
ax.set_ylim(0, 10)
ax.set_aspect('equal')
ax.axis('off')

ax.text(5.5, 8.7, 'Data Interpretation Decision Tree', ha='center',
        fontsize=12, fontweight='bold', color=COLORS['primary'])

# Start
draw_terminal(ax, 5.5, 8.2, 2.5, 0.5, 'START: Data QC', COLORS['light_green'])

# First decision
draw_decision_diamond(ax, 5.5, 7.0, 1.4, 'Reciprocity\nOK?', COLORS['light_blue'])
draw_flow_arrow(ax, (5.5, 7.95), (5.5, 7.7))

# Poor reciprocity path
draw_flow_arrow(ax, (4.8, 7.0), (3.0, 7.0), 'No')
draw_process_box(ax, 1.8, 7.0, 1.8, 0.8, 'Check\nconnections\n& reacquire', COLORS['light_red'])
draw_flow_arrow(ax, (1.8, 7.4), (1.8, 8.2))
ax.annotate('', xy=(5.5, 8.2), xytext=(2.7, 8.2),
            arrowprops=dict(arrowstyle='->', color='black', lw=1.5))

# Good data path
draw_flow_arrow(ax, (5.5, 6.3), (5.5, 5.7), 'Yes')
draw_decision_diamond(ax, 5.5, 5.2, 1.4, 'MIT\nAnomaly?', COLORS['light_blue'])

# Strong MIT path
draw_flow_arrow(ax, (6.2, 5.2), (8.0, 5.2), 'Strong')
draw_decision_diamond(ax, 9.0, 5.2, 1.2, 'ERT\nContrast?', COLORS['light_blue'])

draw_flow_arrow(ax, (9.0, 4.6), (9.0, 3.8), 'Yes')
draw_process_box(ax, 9.0, 3.3, 2.0, 0.8, 'Metal in\ndisturbed zone\n(HIGH priority)', COLORS['light_red'])

draw_flow_arrow(ax, (9.6, 5.2), (10.3, 5.2), 'No')
draw_process_box(ax, 10.3, 5.2, 1.2, 0.6, 'Isolated\nmetal', COLORS['light_orange'])

# Weak/No MIT path
draw_flow_arrow(ax, (5.5, 4.5), (5.5, 3.8), 'Weak/None')
draw_decision_diamond(ax, 5.5, 3.3, 1.4, 'ERT\nAnomaly?', COLORS['light_blue'])

draw_flow_arrow(ax, (6.2, 3.3), (7.5, 3.3), 'Yes')
draw_decision_diamond(ax, 8.3, 3.3, 1.0, 'High\nor Low\nR?', COLORS['light_blue'])

draw_flow_arrow(ax, (8.8, 3.3), (10.0, 3.3), 'High')
draw_process_box(ax, 10.0, 3.3, 1.5, 0.6, 'Void or\ndry zone', COLORS['light_purple'])

draw_flow_arrow(ax, (8.3, 2.8), (8.3, 2.2), 'Low')
draw_process_box(ax, 8.3, 1.7, 1.8, 0.7, 'Wet fill or\nclay layer', COLORS['light_blue'])

draw_flow_arrow(ax, (5.5, 2.6), (5.5, 1.8), 'No')
draw_process_box(ax, 5.5, 1.3, 2.2, 0.8, 'Homogeneous\nground\n(no targets)', COLORS['light_green'])

# Priority legend
ax.add_patch(FancyBboxPatch((0.5, 0.3), 10.0, 0.8,
                             boxstyle="round,pad=0.02",
                             facecolor=COLORS['light_blue'], alpha=0.3,
                             edgecolor=COLORS['accent'], lw=1.5))

priority_items = [
    (1.5, 0.7, 'HIGH', COLORS['warning'], 'Metal + Disturbed'),
    (4.0, 0.7, 'MEDIUM', COLORS['orange'], 'Metal or Fill only'),
    (6.8, 0.7, 'LOW', COLORS['success'], 'Minor anomalies'),
    (9.2, 0.7, 'NONE', COLORS['gray_light'], 'No targets'),
]

for x, y, label, color, desc in priority_items:
    ax.add_patch(Circle((x - 0.3, y), 0.15, facecolor=color, edgecolor='black', lw=1))
    ax.text(x, y, f'{label}:', fontsize=8, fontweight='bold', va='center')
    ax.text(x + 0.8, y, desc, fontsize=7, va='center', color=COLORS['gray_dark'])

plt.tight_layout()
plt.show()
```

## Example Interpretation Scenarios

### Scenario 1: Bomb Crater Investigation

- **MIT:** Metal parts detected near crater base (aluminum/steel fragments)
- **ERT:** Fill bowl geometry visible, wet pockets at base, clear crater walls
- **Interpretation:** Classic impact crater with retained metallic debris

### Scenario 2: Woods Burial Search

- **MIT:** Small metallic clusters (buckles, dog tags, buttons)
- **ERT:** Rectangular disturbed zone with different moisture profile
- **Interpretation:** Possible grave shaft requiring careful investigation

### Scenario 3: Aircraft Wreckage

- **MIT:** Large conductive masses (engine block, landing gear)
- **ERT:** Disturbed ground pattern, possible fuel contamination zones
- **Interpretation:** Significant wreckage concentration warranting excavation

## Data Quality Indicators {#sec-quality-indicators}

## Good Data Characteristics

- Consistent reciprocity (A-to-B approximately equals B-to-A)
- Smooth spatial variations without erratic jumps
- Expected depth sensitivity matching configuration
- Stable baseline measurements over survey duration

::: {.callout-warning}
## Problematic Data Warning Signs

- Poor reciprocity indicates coupling problems or calibration drift
- Noisy/spiky readings suggest connection issues or EMI
- No depth sensitivity may indicate inadequate spacing or frequency
- Inconsistent repeats require checking timebase and connectors
:::

## Field Expectations and Detection Limits {#sec-detection-limits}

## Typical Anomaly Sizes

| Target Type | Typical Size | Expected Response |
|-------------|--------------|-------------------|
| Large metal (engine) | 1-3 m | Strong MIT response |
| Small metal (artifacts) | 0.1-0.5 m | Weaker MIT, requires tight spacing |
| Grave shaft | 0.5-1.5 m wide | Clear ERT contrast |
| Crater fill | 10-15 m diameter | ERT shows boundaries clearly |

: Typical anomaly sizes and expected responses {#tbl-anomaly-sizes}

## Detection Limits

- **MIT:** Can detect ~0.1m metal at 1-2m depth (size dependent)
- **ERT:** Can resolve ~0.5m features at 1-2m depth
- **Depth:** Practical limit 2-4m typical with 3m probes (5-6m in optimal conditions)

## Post-Survey Workflow {#sec-post-survey}

1. **QA/QC:** Verify data quality and reciprocity
2. **Inversion:** Reconstruct 3D models using appropriate algorithms
3. **Fusion:** Combine MIT and ERT results for complete picture
4. **Visualization:** Generate depth slices and 3D isosurfaces
5. **Interpretation:** Correlate anomalies with site context
6. **Reporting:** Document findings with confidence assessments
7. **Planning:** Recommend excavation priorities and methods

::: {.callout-note}
## Key Interpretation Principles

- Always combine MIT and ERT for complete subsurface picture
- Consider site history and expected target characteristics
- Use confidence levels to guide excavation prioritization
- Document interpretation rationale for future reference
:::

## Mathematical Basis of Reconstruction {#sec-math-basis}

For scientific rigor, it is important to define the physical models governing the reconstruction algorithms. The inversion process solves the 'inverse problem': finding the subsurface property distribution that best explains the measured data.

## Forward Models

**MIT (Quasi-Static Maxwell's Equations):** The secondary magnetic field B_s generated by eddy currents in a conductive medium is governed by:

$$\nabla \times \mathbf{E} = -i \omega \mathbf{B}$$

$$\nabla \times \mathbf{H} = \sigma \mathbf{E} + \mathbf{J}_s$$

Where $\sigma$ is conductivity, $\omega$ is angular frequency, and $\mathbf{J}_s$ is the source current.

**ERT (Poisson's Equation):** The electric potential $\phi$ distribution due to a current source $I$ in a medium of conductivity $\sigma$ is governed by:

$$\nabla \cdot (\sigma \nabla \phi) = -I \delta(\mathbf{r} - \mathbf{r}_s)$$

## Inverse Problem Formulation

The reconstruction minimizes an objective function $\Phi$ comprising data mismatch and model roughness (regularization):

$$\Phi(\mathbf{m}) = \| \mathbf{d}_{obs} - F(\mathbf{m}) \|^2 + \lambda \| \mathbf{R} \mathbf{m} \|^2$$

Where $\mathbf{d}_{obs}$ is observed data, $F(\mathbf{m})$ is the forward model output for model $\mathbf{m}$, $\mathbf{R}$ is the roughness matrix, and $\lambda$ is the regularization parameter. This is typically solved using a Gauss-Newton iterative update:

$$\mathbf{m}_{k+1} = \mathbf{m}_k - (\mathbf{J}^T \mathbf{J} + \lambda \mathbf{R}^T \mathbf{R})^{-1} \mathbf{J}^T (\mathbf{d}_{obs} - F(\mathbf{m}_k))$$

Where $\mathbf{J}$ is the Sensitivity Matrix (Jacobian) describing how data changes with model parameters.
