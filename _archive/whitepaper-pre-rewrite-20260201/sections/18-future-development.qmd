---
title: "Future Development"
---

## Overview {#sec-future-overview}

This document has focused on **hardware and field methods**. The next phase involves **software development** for data processing, inversion, and visualization, as well as continued hardware improvements.

The software development is **explicitly separate** from the hardware/field guide presented in this document. The hardware system is designed to collect high-quality data that can be processed with standard or custom software tools.

## Development Roadmap {#sec-development-roadmap}

The HIRT project follows a phased development approach, with parallel tracks for software and hardware improvements. The timeline below illustrates the planned progression from basic data processing to advanced visualization and machine learning capabilities.

```{python}
#| label: fig-development-roadmap
#| fig-cap: "Development roadmap showing software phases (top track) and hardware improvements (bottom track). Key milestones include Alpha (v0.1) at month 3, Beta (v0.5) at month 6, and full Release (v1.0) at month 12."
#| echo: false

import matplotlib.pyplot as plt
from matplotlib.patches import FancyBboxPatch, Rectangle
import numpy as np

# Color palette
COLORS = {
    'primary': '#1a365d',
    'secondary': '#2c5282',
    'accent': '#3182ce',
    'success': '#38a169',
    'warning': '#c53030',
    'orange': '#ed8936',
    'purple': '#805ad5',
    'gray_dark': '#4a5568',
    'gray_med': '#718096',
    'gray_light': '#a0aec0',
    'light_green': '#c6f6d5',
    'light_blue': '#ebf8ff',
    'light_orange': '#feebc8',
    'light_purple': '#e9d8fd',
}

fig, ax = plt.subplots(figsize=(11, 6.5))
ax.set_xlim(0, 12)
ax.set_ylim(0, 7)
ax.axis('off')

# Title
ax.text(6, 6.7, 'HIRT Development Roadmap', ha='center',
       fontsize=14, fontweight='bold', color=COLORS['primary'])

# Timeline axis
ax.axhline(y=3.5, xmin=0.08, xmax=0.92, color=COLORS['gray_dark'], linewidth=2)

# Month markers
months = ['M1', 'M2', 'M3', 'M4', 'M5', 'M6', 'M7', 'M8', 'M9', 'M10', 'M11', 'M12']
for i, month in enumerate(months):
    x = 1 + i * 0.9
    ax.plot([x, x], [3.4, 3.6], color=COLORS['gray_dark'], linewidth=2)
    ax.text(x, 3.2, month, ha='center', fontsize=7, color=COLORS['gray_med'])

# Phase 1: Basic Processing (Months 1-3) - Software
phase1_box = FancyBboxPatch((0.8, 4.2), 2.7, 1.8, boxstyle="round,pad=0.03",
                             facecolor=COLORS['light_blue'], edgecolor=COLORS['accent'],
                             linewidth=2)
ax.add_patch(phase1_box)
ax.text(2.15, 5.7, 'Phase 1: Basic Processing', ha='center', fontsize=9,
       fontweight='bold', color=COLORS['accent'])
ax.text(2.15, 5.3, 'Months 1-3', ha='center', fontsize=7, color=COLORS['gray_dark'])
phase1_items = ['Data import/export', 'Basic QC tools', 'Simple visualization']
for i, item in enumerate(phase1_items):
    ax.text(1.0, 5.0 - i * 0.3, f'\u2022 {item}', fontsize=7, va='center')

# Phase 2: Inversion (Months 4-6) - Software
phase2_box = FancyBboxPatch((3.7, 4.2), 2.7, 1.8, boxstyle="round,pad=0.03",
                             facecolor=COLORS['light_green'], edgecolor=COLORS['success'],
                             linewidth=2)
ax.add_patch(phase2_box)
ax.text(5.05, 5.7, 'Phase 2: Inversion', ha='center', fontsize=9,
       fontweight='bold', color=COLORS['success'])
ax.text(5.05, 5.3, 'Months 4-6', ha='center', fontsize=7, color=COLORS['gray_dark'])
phase2_items = ['Forward modeling', 'Inversion algorithms', 'Basic data fusion']
for i, item in enumerate(phase2_items):
    ax.text(3.9, 5.0 - i * 0.3, f'\u2022 {item}', fontsize=7, va='center')

# Phase 3: Advanced Features (Months 7-12) - Software
phase3_box = FancyBboxPatch((6.6, 4.2), 4.5, 1.8, boxstyle="round,pad=0.03",
                             facecolor=COLORS['light_purple'], edgecolor=COLORS['purple'],
                             linewidth=2)
ax.add_patch(phase3_box)
ax.text(8.85, 5.7, 'Phase 3: Advanced Features', ha='center', fontsize=9,
       fontweight='bold', color=COLORS['purple'])
ax.text(8.85, 5.3, 'Months 7-12', ha='center', fontsize=7, color=COLORS['gray_dark'])
phase3_items = ['Advanced 3D visualization', 'Machine learning integration',
               'User interface development', 'Complete documentation']
for i, item in enumerate(phase3_items):
    ax.text(6.8, 5.0 - i * 0.25, f'\u2022 {item}', fontsize=7, va='center')

# Hardware track label
ax.text(0.3, 1.8, 'HARDWARE\nTRACK', ha='center', fontsize=8, fontweight='bold',
       color=COLORS['orange'], va='center')

# Hardware improvements timeline (below main timeline)
hw_phases = [
    (1.5, 'Current:\n16mm Modular', COLORS['light_green'], COLORS['success']),
    (4, 'Wireless\nProbes', COLORS['light_orange'], COLORS['orange']),
    (6.5, 'Higher\nChannel Count', COLORS['light_orange'], COLORS['orange']),
    (9, 'Real-time\nProcessing', COLORS['light_blue'], COLORS['accent']),
]

for x, label, facecolor, edgecolor in hw_phases:
    hw_box = FancyBboxPatch((x - 1, 0.8), 2, 1.2, boxstyle="round,pad=0.02",
                            facecolor=facecolor, edgecolor=edgecolor, linewidth=1.5)
    ax.add_patch(hw_box)
    ax.text(x, 1.4, label, ha='center', va='center', fontsize=7, fontweight='bold')
    # Connect to timeline
    ax.annotate('', xy=(x, 3.4), xytext=(x, 2.0),
               arrowprops=dict(arrowstyle='->', color=edgecolor, lw=1.2))

# Arrows between software phases
ax.annotate('', xy=(3.7, 5.1), xytext=(3.5, 5.1),
           arrowprops=dict(arrowstyle='->', color=COLORS['gray_dark'], lw=1.5))
ax.annotate('', xy=(6.6, 5.1), xytext=(6.4, 5.1),
           arrowprops=dict(arrowstyle='->', color=COLORS['gray_dark'], lw=1.5))

# Software track label
ax.text(0.3, 5.1, 'SOFTWARE\nTRACK', ha='center', fontsize=8, fontweight='bold',
       color=COLORS['accent'], va='center')

# Milestone markers
milestones = [
    (2.8, 'v0.1\nAlpha'),
    (5.5, 'v0.5\nBeta'),
    (10.9, 'v1.0\nRelease'),
]
for x, label in milestones:
    ax.plot(x, 3.5, 'D', markersize=10, color=COLORS['warning'])
    ax.text(x, 3.0, label, ha='center', fontsize=7, fontweight='bold',
           color=COLORS['warning'])

# Legend
legend_y = 0.3
ax.add_patch(Rectangle((7.5, legend_y - 0.1), 0.3, 0.2, facecolor=COLORS['light_blue'],
                       edgecolor=COLORS['accent']))
ax.text(8.0, legend_y, 'Software Phase', fontsize=7, va='center')
ax.add_patch(Rectangle((9.5, legend_y - 0.1), 0.3, 0.2, facecolor=COLORS['light_orange'],
                       edgecolor=COLORS['orange']))
ax.text(10.0, legend_y, 'Hardware Phase', fontsize=7, va='center')
ax.plot(11.2, legend_y, 'D', markersize=6, color=COLORS['warning'])
ax.text(11.5, legend_y, 'Milestone', fontsize=7, va='center')

plt.tight_layout()
plt.show()
```

## Firmware Development (Phase 2) {#sec-firmware-development}

The HIRT hardware system requires embedded firmware to operate. This firmware development is explicitly **Phase 2** of the project---the hardware design documented in this whitepaper can be built and bench-tested, but firmware is required for integrated field operation.

### Firmware Scope and Architecture {#sec-firmware-scope}

| Module | Function | Priority |
|--------|----------|----------|
| **DDS Control** | AD9833 SPI initialization, frequency programming, multi-frequency sweep | Core |
| **ADC Interface** | ADS1256 SPI driver, differential sampling, data buffering | Core |
| **Lock-In DSP** | Digital IQ demodulation, amplitude/phase extraction | Core |
| **Multiplexer Control** | CD74HC4067 address sequencing, probe selection logic | Core |
| **ERT Sequencer** | Current source control, polarity reversal timing, compliance monitoring | Core |
| **USB Data Logger** | Real-time CSV streaming, measurement timestamping | Secondary |
| **Configuration UI** | Serial command interface, parameter storage | Secondary |

: Firmware module breakdown and priorities {#tbl-firmware-modules}

### Target Platform: ESP32

The hardware design specifies the **ESP32-WROOM-32** module as the MCU platform, selected for:

- Dual-core 240 MHz processor (adequate for lock-in DSP)
- Built-in WiFi/BLE for future wireless data transfer
- 520 KB SRAM for measurement buffering
- Arduino and ESP-IDF toolchain support
- Wide availability and low cost (<$5 per module)

### Firmware Repository Status

::: {.callout-note}
## Current Status: Not Yet Published

Firmware development is scheduled to begin after hardware validation is complete. The planned repository location is:

**Planned Repository:** `github.com/hirt-project/hirt-firmware`

Contributors interested in early development should contact the project maintainers. Firmware will be released under MIT License to match the hardware documentation.
:::

### Bench Testing Without Firmware {#sec-bench-testing-no-firmware}

Builders can validate hardware subsystems before firmware is available:

1. **DDS Testing:** Use Arduino Uno with AD9833 library to verify sine wave generation
2. **ADC Testing:** Use Arduino with ADS1256 library to verify signal acquisition
3. **Coil Testing:** Apply known signal to TX coil, measure RX coil with oscilloscope
4. **ERT Current Source:** Verify compliance voltage and current accuracy with resistor loads
5. **Multiplexer Testing:** Manually step through channels with GPIO to verify routing

These individual tests confirm hardware function before integrated firmware is available.

## Software Development Pipeline {#sec-software-pipeline}

### Data QA/QC (Quality Assurance/Quality Control) {#sec-data-qaqc}

The first stage of the processing pipeline involves comprehensive data validation and quality control:

- Import CSV data files with automatic format detection
- Check for missing or corrupted data entries
- Verify reciprocity (A to B approximately equals B to A)
- Remove outliers and flag suspicious measurements for review
- Generate data quality metrics and visualization reports

### MIT Inversion {#sec-mit-inversion}

Magnetic Induction Tomography inversion converts amplitude and phase measurements to conductivity distributions:

- Forward modeling: Predict measurements from conductivity model
- Inverse modeling: Reconstruct conductivity from measurements
- Multi-frequency handling for depth resolution
- Regularization for stable, physically meaningful solutions
- Uncertainty quantification for reliability assessment

### ERT Inversion {#sec-ert-inversion}

Electrical Resistivity Tomography inversion converts voltage/current measurements to resistivity volumes:

- DC resistivity forward solver (finite element/difference)
- Inversion algorithm with Gauss-Newton or Occam's method
- Electrode position and depth accounting
- Topography handling for non-flat surfaces
- Cross-borehole measurement geometry support

### Data Fusion {#sec-data-fusion}

Combining MIT and ERT data provides complementary information:

- Co-registration of MIT and ERT volumes
- Unified 3D model generation
- Overlay capabilities with GPR, magnetometry, photogrammetry data
- Multi-parameter visualization and interpretation

## Feature Priority Matrix {#sec-feature-priority}

Features are prioritized based on user impact versus implementation effort. Quick wins (high impact, low effort) receive immediate attention, while major projects are scheduled according to available resources and dependencies.

```{python}
#| label: fig-feature-priority
#| fig-cap: "Feature priority matrix categorizing development items by implementation effort (x-axis) and user impact (y-axis). Bubble size indicates relative priority. Quick wins include data QA/QC and basic visualization; major projects include MIT/ERT inversion and 3D visualization."
#| echo: false

import matplotlib.pyplot as plt
import matplotlib.patheffects as path_effects
import numpy as np

# Color palette
COLORS = {
    'primary': '#1a365d',
    'success': '#38a169',
    'warning': '#c53030',
    'orange': '#ed8936',
    'accent': '#3182ce',
    'gray_dark': '#4a5568',
    'light_green': '#c6f6d5',
    'light_blue': '#ebf8ff',
    'light_orange': '#feebc8',
    'light_red': '#fed7d7',
}

fig, ax = plt.subplots(figsize=(10, 8))
ax.set_xlim(0, 10)
ax.set_ylim(0, 10)

# Background quadrants
ax.fill_between([0, 5], [5, 5], [10, 10], color=COLORS['light_green'], alpha=0.3)  # Quick Wins
ax.fill_between([5, 10], [5, 5], [10, 10], color=COLORS['light_orange'], alpha=0.3)  # Major Projects
ax.fill_between([0, 5], [0, 0], [5, 5], color=COLORS['light_blue'], alpha=0.3)  # Fill-ins
ax.fill_between([5, 10], [0, 0], [5, 5], color=COLORS['light_red'], alpha=0.3)  # Avoid

# Quadrant labels
ax.text(2.5, 9.3, 'QUICK WINS', ha='center', fontsize=11, fontweight='bold',
       color=COLORS['success'])
ax.text(2.5, 8.9, 'High Impact, Low Effort', ha='center', fontsize=8,
       color=COLORS['gray_dark'], style='italic')

ax.text(7.5, 9.3, 'MAJOR PROJECTS', ha='center', fontsize=11, fontweight='bold',
       color=COLORS['orange'])
ax.text(7.5, 8.9, 'High Impact, High Effort', ha='center', fontsize=8,
       color=COLORS['gray_dark'], style='italic')

ax.text(2.5, 0.7, 'FILL-INS', ha='center', fontsize=11, fontweight='bold',
       color=COLORS['accent'])
ax.text(2.5, 0.3, 'Low Impact, Low Effort', ha='center', fontsize=8,
       color=COLORS['gray_dark'], style='italic')

ax.text(7.5, 0.7, 'AVOID', ha='center', fontsize=11, fontweight='bold',
       color=COLORS['warning'])
ax.text(7.5, 0.3, 'Low Impact, High Effort', ha='center', fontsize=8,
       color=COLORS['gray_dark'], style='italic')

# Center lines
ax.axhline(y=5, color=COLORS['gray_dark'], linewidth=1.5, linestyle='--', alpha=0.5)
ax.axvline(x=5, color=COLORS['gray_dark'], linewidth=1.5, linestyle='--', alpha=0.5)

# Features as bubbles (x=effort, y=impact, size=priority)
features = [
    # Quick Wins (low effort, high impact)
    (1.5, 8.5, 400, 'Data QA/QC', COLORS['success']),
    (3, 7.5, 350, 'CSV Import', COLORS['success']),
    (2, 6.5, 300, 'Basic Viz', COLORS['success']),
    (4, 8, 280, 'Reciprocity\nCheck', COLORS['success']),

    # Major Projects (high effort, high impact)
    (7, 8.5, 500, 'MIT\nInversion', COLORS['orange']),
    (8.5, 7.5, 480, 'ERT\nInversion', COLORS['orange']),
    (6.5, 6.5, 400, 'Data Fusion', COLORS['orange']),
    (8, 5.8, 350, '3D\nVisualization', COLORS['orange']),

    # Fill-ins (low effort, low impact)
    (2, 3.5, 200, 'GIS Export', COLORS['accent']),
    (3.5, 2.5, 180, 'File Format\nSupport', COLORS['accent']),
    (1.5, 1.8, 150, 'Config\nTemplates', COLORS['accent']),

    # Avoid/Defer (high effort, low impact)
    (7, 2.5, 220, 'Automated\nDeployment', COLORS['warning']),
    (8.5, 3.5, 200, 'Real-time\nInversion', COLORS['warning']),
]

for effort, impact, size, label, color in features:
    ax.scatter(effort, impact, s=size, c=color, alpha=0.7, edgecolors='black', linewidth=1)
    ax.text(effort, impact, label, ha='center', va='center', fontsize=6,
           fontweight='bold', color='white',
           path_effects=[path_effects.withStroke(linewidth=2, foreground='black')])

# Axes labels
ax.set_xlabel('Implementation Effort', fontsize=11, fontweight='bold',
             color=COLORS['primary'])
ax.set_ylabel('User Impact', fontsize=11, fontweight='bold',
             color=COLORS['primary'])

# Custom tick labels
ax.set_xticks([0, 2.5, 5, 7.5, 10])
ax.set_xticklabels(['', 'Low', '', 'High', ''], fontsize=9)
ax.set_yticks([0, 2.5, 5, 7.5, 10])
ax.set_yticklabels(['', 'Low', '', 'High', ''], fontsize=9)

# Title
ax.set_title('Feature Priority Matrix\n', fontsize=14, fontweight='bold',
            color=COLORS['primary'])

# Size legend
ax.text(9.5, 4.3, 'Bubble size =\nPriority', ha='center', fontsize=7,
       color=COLORS['gray_dark'], style='italic')

# Grid
ax.grid(True, alpha=0.2)
ax.set_axisbelow(True)

plt.tight_layout()
plt.show()
```

## Software Architecture {#sec-software-architecture}

### Language and Library Considerations {#sec-language-considerations}

The software stack is designed for scientific computing efficiency and accessibility:

| Language | Strengths | Considerations |
|----------|-----------|----------------|
| Python | Scientific libraries, community support | Primary development language |
| MATLAB | Powerful, well-documented | Requires license |
| C++ | High performance | Core algorithm optimization |
| Hybrid | Best of both worlds | Python high-level, C++ intensive computation |

: Language options for software development {#tbl-language-options}

### Key Libraries and Tools {#sec-key-libraries}

| Library/Tool | Purpose | Notes |
|--------------|---------|-------|
| NumPy/SciPy | Numerical computing | Foundation for all calculations |
| VTK/ParaView | 3D visualization | Professional rendering |
| PyVista | Python 3D visualization | VTK wrapper for ease of use |
| ResIPy/pyGIMLi | ERT inversion | Existing mature tools |
| SimPEG | EM modeling and inversion | Comprehensive framework |

: Recommended libraries and tools for HIRT software {#tbl-libraries-tools}

## Planned Hardware Improvements {#sec-hardware-improvements}

### Wireless Probes {#sec-wireless-probes}

Wireless communication would significantly reduce cable management complexity and enable faster deployment:

- LoRa or BLE communication protocols under evaluation
- Balance power consumption versus convenience
- Maintain data integrity and timing synchronization
- Consider field-replaceable battery modules

### Higher Channel Count {#sec-higher-channels}

- Increased probe density for finer resolution
- Modular expansion through daisy-chaining
- Enhanced multiplexing architecture
- Scalable from 4 to 16+ probes

### Real-time Processing {#sec-realtime-processing}

- Process data during collection
- Enable adaptive survey strategies
- Immediate quality feedback in the field
- Requires edge computing capability (e.g., Raspberry Pi, Jetson)

## Forward Modeling and Validation {#sec-forward-modeling}

Before field deployment, the HIRT system response should be validated using synthetic models. Recommended tools include:

| Tool | Focus | Strengths | URL |
|------|-------|-----------|-----|
| SimPEG | MIT + ERT | Full forward/inverse modeling, Python | [simpeg.xyz](https://simpeg.xyz) |
| pyGIMLi | ERT-focused | Excellent visualization, mature | [pygimli.org](https://pygimli.org) |
| empymod | 1D layered EM | Fast, accurate for stratified media | [empymod.emsig.xyz](https://empymod.emsig.xyz) |

: Recommended forward modeling tools {#tbl-forward-modeling}

### HIRT-Relevant Tutorials and Workflows {#sec-relevant-tutorials}

The following tutorials from these packages are directly applicable to HIRT data processing:

**SimPEG Tutorials:**

- *DC Resistivity 3D Inversion* - Demonstrates `Simulation3DCellCentered` for borehole data
- *OcTree Mesh for DC/IP* - Efficient mesh refinement near electrodes
- *Electrode Draping* - Handles topography with `drape_electrodes_on_topography`

**pyGIMLi Tutorials:**

- *Crosshole ERT* - Published example with 144 electrodes across 9 boreholes, 1,256 measurements
- *Timelapse ERT* - `CrossholeERT` class for temporal monitoring applications
- *Regularization Options* - zWeight adjustment for anisotropic smoothing

**empymod Applications:**

- Loop source modeling for 2-50 kHz range (HIRT operating frequencies)
- Layered-earth forward modeling validates HIRT physics assumptions
- In-phase/Quadrature decomposition: Real component = resistive response, Imaginary component = inductive response

### Data Export Integration Path {#sec-export-integration}

HIRT field data should be exported in standard formats compatible with inversion packages:

1. **HIRT Field Data** (.csv) - Raw measurements from probes
2. **Format Conversion** - Python script transforms to target format
3. **Target Formats:**
   - SimPEG: Survey + Data objects
   - pyGIMLi: DataContainerERT
   - empymod: 1D layered parameters
4. **Inversion / Forward Modeling** - Run with chosen package
5. **Output:** 3D Model + Uncertainty Estimates

### Open-Source Hardware Reference: OhmPi {#sec-ohmpi-reference}

The OhmPi project ([ohmpi.org](https://ohmpi.org)) provides a valuable reference design for open-source resistivity instrumentation:

| Specification | OhmPi | HIRT ERT |
|--------------|-------|----------|
| Architecture | Raspberry Pi + ADS1115 ADC | Custom MCU + ADC |
| Channels | 32 electrodes standard | Scalable, 4+ probes |
| Current range | 0.1-80 mA | 0.5-2 mA (safety limited) |
| Voltage range | 0.001-12 V | Similar |
| Cost | <$500 (32 channel) | Target similar |
| Philosophy | Open-source, DIY | Open-source, DIY |

: Comparison of OhmPi and HIRT ERT specifications {#tbl-ohmpi-comparison}

OhmPi demonstrates that research-grade resistivity measurements are achievable with commodity electronics. Their Raspberry Pi architecture and ADS1115 ADC approach may inform future HIRT development, particularly for the base station/hub electronics.

### Standard Validation Scenarios {#sec-validation-scenarios}

Four standard scenarios are recommended for system validation:

1. **Aluminum Bomb in Sandy Loam:** 1m diameter sphere at 3m depth in 0.1 S/m soil - validates MIT response to non-ferrous UXO
2. **Grave Shaft (Disturbed Fill):** 0.8x0.5x1.5m prism with 0.05 S/m fill in 0.2 S/m clay - validates ERT contrast detection
3. **Scattered Aircraft Debris:** Multiple fragments (0.2-1m) at 1-4m depths - validates MIT multi-target discrimination
4. **Bomb Crater with Heterogeneous Fill:** 8m diameter, 5m deep crater with variable conductivity - tests combined MIT+ERT response

## Known Limitations {#sec-known-limitations}

::: {.callout-note}
## Technical Limitations

- Smaller coil area results in ~19 dB SNR loss (compensated by longer integration)
- Survey time increases 5-10x compared to commercial systems
- Post-processing software required for 3D reconstruction
- Limited depth penetration in highly conductive soils
:::

::: {.callout-note}
## Current System Constraints

- Electronics SNR adequate for detection but compromised for precise characterization
- Phase accuracy: +/-5 degrees (vs. commercial +/-0.5 degrees)
- Noise floor: ~100 nV (vs. commercial ~10 nV)
:::

## Machine Learning Opportunities {#sec-machine-learning}

Machine learning presents opportunities for automated analysis and interpretation:

- **Anomaly detection:** Automatically identify targets of interest
- **Classification:** Distinguish metal vs. void vs. disturbed soil
- **Quality assessment:** Predict data quality from acquisition parameters
- **Parameter estimation:** Estimate target properties (size, depth, conductivity)

::: {.callout-tip}
## Note
Machine learning integration requires labeled training data from both synthetic forward models and validated field measurements.
:::

## Documentation Needs {#sec-documentation-needs}

### User Documentation {#sec-user-docs}

- Processing workflow guide with step-by-step instructions
- Parameter selection guidelines for different survey types
- Interpretation guide with example datasets
- Troubleshooting common issues

### Technical Documentation {#sec-tech-docs}

- Algorithm descriptions with mathematical derivations
- Code documentation (docstrings, API reference)
- Validation studies with synthetic and field data
- Performance benchmarks for different hardware configurations

## Software References {#sec-software-references}

1. Cockett, R., Kang, S., Heagy, L. J., Pidlisecky, A., & Oldenburg, D. W. (2015). SimPEG: An open source framework for simulation and gradient based parameter estimation in geophysical applications. *Computers & Geosciences*, 85, 142-154. [DOI: 10.1016/j.cageo.2015.09.015](https://doi.org/10.1016/j.cageo.2015.09.015)

2. Rücker, C., Günther, T., & Wagner, F. M. (2017). pyGIMLi: An open-source library for modelling and inversion in geophysics. *Computers & Geosciences*, 109, 106-123. [DOI: 10.1016/j.cageo.2017.07.011](https://doi.org/10.1016/j.cageo.2017.07.011)

3. Werthmüller, D. (2017). An open-source full 3D electromagnetic modeler for 1D VTI media in Python: empymod. *Geophysics*, 82(6), WB9-WB19. [DOI: 10.1190/geo2016-0626.1](https://doi.org/10.1190/geo2016-0626.1)
